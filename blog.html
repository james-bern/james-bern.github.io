<!doctype html>
<html lang="en">
 <head>
  <title>blog</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="mvp.css"> 
  <style>
body { max-width: 42rem; margin: 3rem auto; padding: 0 1rem; font-family: system-ui, sans-serif; line-height: 1.6; }
time { color: #666; font-size: 0.9rem; }
pre { background: #FEF0E0; padding: 1rem; overflow-x: auto; border-radius: 10px; font-size: 0.9rem; }
pre { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
h2 .permalink:hover::after { content: " ¶"; font-size: 0.9em; }
  </style>

 </head>
 <body>

<h1>blog</h1>
<p>let's make a CAD program!</p>

<!-- TODO BYOprintf -->

<article>
<h2 id="0000"><a href="#0000" class="permalink">BYOprintf</a></h2>
<time>sat, dec 20</time>
<p><i>writing stuff from scratch is delightfully infective</i></p>
<p>i started using <a href="https://x.com/vkrajacic/status/1730891609191981305">Vjekoslav Krajačić-style sliceable strings</a> a while back</p>
<pre>
STRUCT {
 U8 *_; // NOTE i usually name this kind of thing `_`; you could also use `data` or `v` or whatever
 U64 length;
} String;</pre>
<p>they're great. you can slice in O(1) and you don't need to null-terminate them</p>
<pre>// NOTE analogous to Python's string[start:one_past_end]
String _string_slice(String string, U32 start, U32 one_past_end) {
 // NOTE we allow empty slices
 ASSERT(start <= string.length);
 ASSERT(start <= one_past_end);
 ASSERT(one_past_end <= string.length);

 String result;
 result._ = &string._[start];
 result.length = (one_past_end - start);
 return(result);
}

// NOTE analogous to Python's string[start:]
String string_slice(String string, U32 start) {
 return _string_slice(string, start, string.length);
}</pre>
<p>the only downside i experienced using these String's was that the standard `printf` didn't know about them -- if you pass a non-null terminated one of these String's with `%s`, `printf` will just goes marching merrily off into the distance, looking for a 0 that may never come</p>
<p>i saw two ways around this (like always, there are probably more options than just these):<br>
A) remember to add null-terminators whenever i wanted to print of sprint, or<br>
B) bring your own printf</p>
<p>conventional wisdom has that option (B) is Bad and Hard, but conventional wisdom is basically always wrong, so let's go with option (B)</p>
<p><a href="https://x.com/rfleury/status/1902138409365467439">like many Hard things</a>, it ended up taking about 5 minutes:<br>
1) borrow <a href="https://github.com/mpaland/printf">Marco Paland's tiny printf from GitHub</a>, and<br>
2) add ~20 mostly copy-and-pasted lines to it<p>
<pre>case 'S' : { // our custom String struct
 String string = va_arg(va, String);
 const char *p = string._;
 unsigned int l = (unsigned int) string.length;
 if (l) {
  // NOTE this block copy and pasted from case 's'
  ...
 }
}</pre>
<p>that's it.</p>
<p>and now we can do stuff like this...</p>
<pre>printf("[gui_tracked_box] box->key_string clash: %S\n", box->key_string);</pre>
<p>and since `snprintf` and `vsnprintf` also know about our String's now, we can use `%S` format specifiers in other functions, like...</p>
<pre>GUIBox *box_field_buffer = gui_tracked_box(
 "buffer_%S%S%S",
 string_prefix,
 command->string,
 field->name
);</pre>
<p><center>:D</center></p>
<p>sidenote: while i was in the neighborhood, i made a small change to `_internal_vsnprintf(...)` -- i prefer my functions to just crash the program when they fail, rather than returning some number i'll forget to check for and then spend hours trying to debug the downstream effects of</p>
<pre>int _internal_vsnprintf(...) {
 ...

 // // NOTE (copied from the printf docs)                                                                        
 // \return The number of characters that COULD have been written into the buffer, not counting the terminating  
 //         null character. A value equal or larger than count indicates truncation. Only when the returned value
 //         is non-negative and less than count, the result has been completely written.                         

 B32 success = (1
  && (result >= 0)
  && ((size_t) result < maxlen)
 );
 if (!success) {
  *((volatile S32 *) 0) = 0; // (crash)
 }

 return(result);
}</pre>
</article>




<article>
<h2 id="0000"><a href="#0000" class="permalink">styling C99 for editability</a></h2>
<time>wed, dec 17</time>
<p><i>i like it being able to easily delete lines and swap lines without having to think about C's syntax;
 one useful family of tricks is to avoid syntactic "special cases" -- basically, the first and last of something should be styled just like the things in the middle</i></p>
<p>here's how i initialize structs</p>
<pre>{
 a,
 b,
 c, // <- i put a comma here (NOTE trailing comma in struct-initialization is valid C)
}</pre>
<p>here's how i write an else-if ladder</p>
<pre>
if (0) { // <- i put an `if (0)` here (NOTE 0 is false)
} else if (...) {
...
} else if (...) {
...
} else if (...) {
...
}</pre>
<p>here's how i write an AND chain</p>
<pre>
(1 // <- i put a `1` here (NOTE 1 is true)
&& ...
&& ...
&& ...
)</pre>
<p>here's an example snippet from Conversation's source</p>
<pre>
B32 is_prinicipal_frame = (1
&& R32_is_zero(part_projection->signed_distance_from_unprojected_origin_to_feature_plane) 
&& geom3d_vector_has_unit_length(part_projection->normal) 
&& R32_are_equal(1.0F, vec3_max(part_projection->normal))
);
if (0
|| (!part_projection->is_active)
|| (!is_prinicipal_frame)
) {
...
}</pre>
<p><i>it's a shame HolyC didn't catch on, because i think it allowed you to include a trailing comma in function calls and
 that would have been siiick</i></p>
</article>




</body>
</html>


