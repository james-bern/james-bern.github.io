<html> <head> <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"> <meta http-equiv="Pragma" content="no-cache"> <meta http-equiv="Expires" content="0"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="robots" content="noindex"> <title></title>
<script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } }; </script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script>
<link rel="stylesheet" href="csci-371.css">
</head><body><div class="content">

<a href="csci-371.html"><b><- back</b></a> <button onClick="window.print()" style="float:right;">print this page</button>


<center><b>hw00</b>
<a href="https://github.com/james-bern/CSCI-371">codebase</a> | <a href="https://github.com/james-bern/CSCI-371/wiki">docs</a> | <a href="https://www.overleaf.com/read/mcyyczwqzbzz">notes</a> | <a href="https://glow.williams.edu/courses/3619655">glow</a>
</center>
<hr>
<b>goals.</b>

- set up the codebase
- learn to use the docs
- learn to love the snail math library
- learn to appreciate the cow app library
- get comfortable with the setup/loop structure of an app

<hr>
<b>0. setup</b>

follow the codebase quickstart guide and verify that you can build and run

you should see rainbow colors, spinning bunnies, hear music (unless you're on Linux), be able to draw on the screen, etc.

<hr>
<b>1. hello codebase</b>

let's make a new app together from scratch
while one could skip straight to the end and finish this problem in about 30 seconds...
...i recommend spending at least 3-6 hours on it

please make the *exact* changes i make, in the order that i make them
and please make the changes the slow way (i.e., by typing) rather than copy and paste
- we are trying to build literal muscle memory; trust me we will need it going forward!

for better or for worse, this will be the last time i micromanage your coding style and process
after this, you will be graded on a "does it work" + "did you make a strong effort" basis

âœ¨ super duper important âœ¨
- build and run your code and investigate what it does after *every single step*
- - experiment!--what *exactly* does the code do? what if i changed this line? got rid of that line?
- - - don't be afraid to change the code!--break the code!--break all the code!
- - i will indicate put the bare minimum things you should try as bullets; but try more stuff than just that!
- rigorously cross-reference the docs as we go (your goal is to understand every single change and every single line)

<details><summary>step 0: (starter code) play with a silly example app</summary>
<codex>#include "include.cpp"

int main() {
    APPS {
        APP(eg_kitchen_sink);
    }
    return 0;
}</codex>
- play with the gui controls
- - how happens when you press <code>j</code> and <code>k</code> on the keyboard?
- - what about <code>r</code>?
- - when you click?
- - double click?
- - (Mac and Windows only) can you turn down the music volume?
- press <code>?</code> on the keyboard while cow is running
- - what does <code>=</code> do?
- - how about <code>~</code>?
</details>
<details><summary>step 1: add a new app</summary>
<codex>#include "include.cpp"

void hw00a() {
    while (cow_begin_frame()) {

    }
}

int main() {
    APPS {
        APP(eg_kitchen_sink);
        APP(hw00a);
    }
    return 0;
}
</codex>
- what's the difference between pressing <code>--></code> (i.e., the right arrow key) and pressing <code>q</code>?
- what's the difference between pressing <code>q</code> and <code>Q</code> (i.e., <code>SHIFT</code> + <code>Q</code>)?
</details>
<details><summary>step 2: add a camera</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    while (cow_begin_frame()) {
        camera_move(&camera);
        camera_attach_to_gui(&camera);
    }
}

int main() {
    APPS {
        APP(eg_kitchen_sink);
        APP(hw00a);
    }
    return 0;
}
</codex>
- right click and drag
- scroll with the mouse wheel (or trackpad)
- inspect <code>camera</code> in a visual debugger (see quickstart guide for debugging info--we will also go over it in class)
</details>
<details><summary>step 3: draw a triangle using easy soup</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    while (cow_begin_frame()) {
        camera_move(&camera);
        camera_attach_to_gui(&camera);
        mat4 PV = camera_get_PV(&camera);

        eso_begin(PV, SOUP_TRIANGLES);
        eso_color(1.0, 0.0, 1.0);
        eso_vertex(0.0, 0.0);
        eso_vertex(1.0, 0.0);
        eso_vertex(0.0, 1.0);
        eso_end();
    }
}

int main() {
    APPS {
        APP(eg_kitchen_sink);
        APP(hw00a);
    }
    return 0;
}
</codex>
- right click and drag
- scroll with the mouse wheel (or trackpad)
- make the triangle yellow
- make the triangle's three vertices each a different color--red, green, and blue
- try, e.g., <code>SOUP_POITNS</code> instead of <code>SOUP_TRIANGLES</code>; what other options are there?
</details>
<details><summary>step 4: (cleanup) get rid of camera gui controls; also i'm sick of those bunnies popping up every time i run the code
- the only thing better than writing code is deleting code :)</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        eso_begin(PV, SOUP_TRIANGLES);
        eso_color(1.0, 0.0, 1.0);
        eso_vertex(0.0, 0.0);
        eso_vertex(1.0, 0.0);
        eso_vertex(0.0, 1.0);
        eso_end();
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
</details>
<details><summary>step 5: (refactor) store the triangle's color vertex positions in the "setup" section of the app (i.e., before the loop);
- this could be a good time to read the beginning of the docs where i talk about our notion of an "app", as well as the end of the docs where i go over snail (our math library)</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        eso_begin(PV, SOUP_TRIANGLES);
        eso_color(color);
        eso_vertex(vertex_positions[0]);
        eso_vertex(vertex_positions[1]);
        eso_vertex(vertex_positions[2]);
        eso_end();
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- what are <code>V2(...)</code> and <code>V3(...)</code> about? do we actually need them here?
- what's going on with, e.g., <code>eso_vertex(...)</code>? it used to take two <code>real</code> numbers; now it's taking just a single <code>vec2</code>...
</details>
<details><summary>step 6: (refactor) use soup instead of easy soup (see docs)</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- what is that <code>NULL</code> about?
- make the triangle's three vertices each a different color--red, green, and blue
</details>
<details><summary>[DON'T ACTUALLY DO THIS] step ðŸ˜¢: compute the triangle's signed area in components
- i.e., the painful, typo-prone way</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    real signed_area = .5 * (vertex_positions[0].x * (vertex_positions[1].y - vertex_positions[2].y) + vertex_positions[1].x * (vertex_positions[2].y - vertex_positions[0].y) + vertex_positions[2].x * (vertex_positions[0].y - vertex_positions[1].y));
    printf("signed_area %lf\n", signed_area);

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- what are <code>.x</code> and <code>.y</code> about?
- what is <code>real</code> about?
- remember <code>printf(...)</code>?
- - if you don't know where your console is, now is a good time to find it!
</details>
<details><summary>step 7: compute the triangle's signed area using snail (i.e., with fun vector operations go snail go)</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
    vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
    real signed_area = .5 * cross(edge_1, edge_2);
    printf("signed_area %lf\n", signed_area);

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- what's up with those minus signs?
- - hint: operator overloading
- where is <code>cross(...)</code> in the docs?
</details>
<details><summary>step 8: make it so we can drag around the triangle's vertices</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
    vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
    real signed_area = .5 * cross(edge_1, edge_2);
    printf("signed_area %lf\n", signed_area);

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- what changes if i swap the order of <code>widget_drag(...)</code> and <code>soup_draw(...)</code>? why?
- what changes if i pass <code>2</code> to <code>widget_drag(...)</code> instead of <code>3</code>?
</details>
<details><summary>step 9: compute (and print) the signed area every frame</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
        vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
        real signed_area = .5 * (cross(edge_1, edge_2));
        printf("signed_area %lf\n", signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
</details>
<details><summary>step 10: print the triangle's signed area to the gui instead of the console
- now our console is free to use for something more interesting!</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
        vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
        real signed_area = .5 * cross(edge_1, edge_2);
        gui_printf("signed_area %lf\n", signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
</details>
<details><summary>[optional] step 11: use <code>gui_readout(...)</code> instead of <code>gui_printf(...)</code>
(if you love <code>gui_printf(...)</code>, feel free to continue using that API; <code>gui_readout(...)</code> is just sugar)</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
        vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
        real signed_area = .5 * cross(edge_1, edge_2);
        gui_readout("signed_area", &signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
</details>
<details><summary>step 12: print the triangle's initial signed area</summary>
<codex>#include "include.cpp"

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    {
        vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
        vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
        real signed_area = .5 * cross(edge_1, edge_2);
        printf("signed_area_0 %lf\n", signed_area);
   }

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
        vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
        real signed_area = .5 * cross(edge_1, edge_2);
        gui_readout("signed_area", &signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- why did i put curly braces around that code i just added?--what happens if you don't?
- - do i get an error, or just a warning? in this particular case, is my code actually broken (i.e., doesn't follow my intent)?
- - - even if the answer is no, i recommend you *get rid of all the warnings*;--no warnings!
</details>
<details><summary>step 13: factor out the triangle signed area computation into a function
- note: i recommend *not* writing a function until you've repeated (very similar) code in at least one or two other places</summary>
<codex>#include "include.cpp"

real get_triangle_signed_area(vec2 *vertex_positions) {
    // vertex_positions should be a pointer to three contiguous vec2's
    // convention: clockwise is positive
    vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
    vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
    return .5 * cross(edge_1, edge_2);
}

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    {
        real signed_area = get_triangle_signed_area(vertex_positions);
        printf("signed_area_0 %lf\n", signed_area);
   }

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        real signed_area = get_triangle_signed_area(vertex_positions);
        gui_readout("signed_area", &signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- note that i've made as few changes as possible
- - first verify the refactored code actually works (i.e., build and run)...
- - ...then you can clean :)
- how is our function different than what we might have written had we not written the usage code first?
- - i.e., if i had just told you "write a function that computes the area of a triangle?," what might you have written?
- - - in what ways would this function be *worse* than the one we ended up with organically?
- - - "WRITE THE USAGE CODE FIRST" --Casey Muratori
</details>
<details><summary>step 14: factor out the triangle signed area computation into a function
- note: i recommend *not* writing a function until you've repeated (very similar) code in at least one or two other places</summary>
<codex>#include "include.cpp"

real get_triangle_signed_area(vec2 *vertex_positions) {
    // vertex_positions should be a pointer to three contiguous vec2's
    // convention: clockwise is positive
    vec2 edge_1 = vertex_positions[1] - vertex_positions[0];
    vec2 edge_2 = vertex_positions[2] - vertex_positions[0];
    return .5 * cross(edge_1, edge_2);
}

void hw00a() {
    Camera2D camera = { 3.0 };

    vec3 color = V3(1.0, 0.0, 1.0);
    vec2 vertex_positions[3] = {
        V2(0.0, 0.0),
        V2(1.0, 0.0),
        V2(0.0, 1.0),
    };

    {
        real signed_area = get_triangle_signed_area(vertex_positions);
        printf("signed_area_0 %lf\n", signed_area);
   }

    while (cow_begin_frame()) {
        camera_move(&camera);
        mat4 PV = camera_get_PV(&camera);

        real signed_area = get_triangle_signed_area(vertex_positions);
        gui_readout("signed_area", &signed_area);

        widget_drag(PV, 3, vertex_positions);
        soup_draw(PV, SOUP_TRIANGLES, 3, vertex_positions, NULL, color);
    }
}

int main() {
    APPS {
        APP(hw00a);
    }
    return 0;
}
</codex>
- note that i've made as few changes as possible
- - first verify the refactored code actually works (i.e., build and run)...
- - ...then you can clean :)
- how is our function different than what we might have written had we not written the usage code first?
- - i.e., if i had just told you "write a function that computes the area of a triangle?," what might you have written?
- - - in what ways would this function be *worse* than the one we ended up with organically?
- - - "WRITE THE USAGE CODE FIRST" --Casey Muratori
</details>

<hr>
<b>2. hello open-ended hw problem</b>
- add a gui button that, when clicked, randomizes the triangle's vertex positions


<hr>
<b>I. hello extra credit</b>

</div></body></html>

